Βραχάς Χρίστος
1115201300024

Παπατσώρης Ιωάννης
1115201300137

***ΕΚΤΕΛΕΣΗ***
./gsp <mode> <cc_threshold>

όπου
  <mode>: s για χρήση scc
  		  c για χρήση cc
  		  n για χρήση πρώτου μέρους 

  <cc_threshold>: το όριο της μετρικής. Αν ξεπεραστεί εκτελείται επανακατασκευή.
 				  Προτεινόμενη τιμή: 1 (καμία ανακατασκευή)

Απαιτείται η προσθήκη του χαρακτήρα S και αλλαγή γραμμής στο τέλος κάθε αρχείου εισόδου αρχικού γράφου,
εάν δεν υπάρχουν. Η επιλογή μεταξύ scc/cc δε γίνεται ακόμα αυτόματα βάση των ενδείξεων STATIC/DYNAMIC
για λόγους πειραματισμού, αλλά θα προστεθεί στο τελικό παραδοτέο.

Έχει υλοποιηθεί ένα Generic Array, το οποίο χρησιμοποιούμε στις περισσότερες περιπτώσεις που
χρειαζόμαστε πίνακα, για αποφυγή επανάληψης κώδικα.

***ΧΡΟΝΙΚΗ ΑΠΟΔΟΣΗ (large dataset)***

Static SCC 	   : ~2min
Static part1   : ~3min

Dynamic CC     : 7min 28sec
Dynamic part1  : 7min 21sec


--------Κομμάτι Στατικού Γράφου--------


***ΓΕΝΙΚΑ***
Για τους στατικούς γράφους, χρησιμοποιούμε πλέον τις SCC αλλά και το ευρετήριο Grail, 
με σκοπό την ταχύτερη απάντηση των queries.
Συγκεκριμένα, αφού δημιουργηθεί ο αρχικός γράφος, βρίσκουμε τις SCC, με τον αλγόριθμο του
Tarjan, ο οποίος έχει υλοποιηθεί επαναληπτικά. 

***TARJAN***
Προκειμένου να διευκολυνθούμε, ορίστηκε μια δομή Vertex, στην οποία κρατάμε διάφορες
πληροφορίες για κάθε κόμβο, που αφορούν την εκτέλεση του Tarjan και μόνο. Εκεί αποθηκεύονται και
οι γείτονες κάθε κόμβου, προκειμένου να αποφύγουμε το overhead συχνής κλήση της συνάρτησης
getNeighbors στον γράφο, κατά τη διάρκεια εκτέλεσης του αλγορίθμου.

***HYPERGRAPH***
Αφού ολοκληρωθεί ο Tarjan, δεδομένου ότι έχουμε όλα τα SCC, ακολουθεί η δημιουργία του
GrailIndex. Εφόσον τα γραφήματα μας μπορούν να έχουν κύκλους, κατασκευάζουμε τον υπεργράφο
που προκύπτει με βάση τα υπολογισμένα SCC, για να δημιουργήσουμε το ευρετήριο. Η κατασκευή
του υπεργράφου γίνεται με μια προσπέλαση όλων των κόμβων του αρχικού γράφου. Ο υπεργράφος
αποθηκεύεται μαζί με τον αρχικό γράφο στη δομή Graph. Υπάρχουν περιπτώσεις, που ο αριθμός των
scc και των κόμβων του γράφου, είναι ίδιος, δηλαδή δεν υπάρχουν πρακτικά κύκλοι με παραπάνω
από έναν κόμβους, οπότε δεν έχει νόημα να δημιουργηθεί υπεργράφος, λόγω του χρόνου που
απαιτείται για τη δημιουργία του, αλλά και της μνήμης που χρειάζεται (ενδεικτικά, στο large, 
2 GB μνήμη). Για τον λόγο αυτό, σε τέτοιες περιπτώσεις χρησιμοποιείται ο αρχικός γράφος, 
έχοντας φροντίσει να αγνοούνται στον αλγόριθμο κατασκευής του Grail, ακμές (u,v), όπου
u == v.

***GRAILINDEX***
-Δημιουργία: Έχει υλοποιηθεί με τέτοιο τρόπο ώστε να μπορούν να υπάρχουν πολλαπλά labels για
κάθε κόμβο. Σε κάθε "δημιουργία", επιλέγεται τυχαία ο πρώτος κόμβος από τον οποίο θα ξεκινήσει
η διαδικασία, και στη συνέχεια γίνονται postorder traversals σε όλους τους κόμβους του γράφου.
-Reachability query: Ανάλογα με το αν έχουμε η όχι υπεργράφο, αφού γίνει η αντιστοίχηση των
node ids, γίνεται n φορές έλεγχος του αν τα labels του κόμβου/scc στόχου είναι υποσύνολο του
source. Αν κανένα δεν επιστρέψει NO, επιστρέφεται MAYBE.

***Διαδικασία που ακολουθείται για απάντηση query σε στατικούς γράφους***
Αφού γίνει το parsing των τιμών των δύο κόμβων, γίνεται κλήση της
OperationsControl::estimateShortestPath(source, target). Σε αυτήν, αρχικά τρέχουμε τον αλγόριθμο
bidirectional bfs, εντός του strongly connected component, αν οι δύο κόμβοι ανήκουν στο ίδιο.
Αν αυτό αποτύχει, τότε γίνεται query στο Grail, κι αν πάρουμε NO, τότε επιστρέφεται -1. Στην
περίπτωση που και αυτο αποτύχει, καλείται ο αλγόριθμος και πάλι, αλλά για όλο τον γράφο, μόνο 
που αυτή τη φορά γίνεται pruning κόμβων-παιδιών, απ τα οποία ο κόμβος source/target δεν είναι
reachable, με χρήση του Grail.

Δεν υλοποιήθηκε η δομή ComponentCursor και η συνάρτηση next_StronglyConnectedComponentID διότι δε μας
χρειάστηκαν άμεσα, αλλά θα προστεθούν πριν τη προφορική εξέταση.


--------Κομμάτι Δυναμικού Γράφου--------


Για το Update Index δοκιμάστηκαν δύο διαφορετικές υλοποιήσεις. Η μία είναι
μονοδιάστατος πίνακας παρόμοιος με αυτόν που προτείνει η εκφώνηση, όπου
γίνεται μια 'αλυσιδωτή' αναζήτηση κάθε φορά ώστε να απαντηθεί εάν ένα
component έχει συνδεθεί με ένα άλλο. Η άλλη είναι ένας πίνακας από
'λίστες', όπου κάθε λίστα κρατάει όλα τα components με τα οποία έχει
συνδεθεί το εκάστοτε component.

Η υλοποίηση με τις λίστες ίσως είναι πιο αργή από την αλυσιδωτή στις
εισαγωγές, αλλά προσφέρει πιο γρήγορο lookup για τα queries, για την ακρίβεια με μια βελτίωση Ο(1) τη
πλειοψηφία των περιπτώσεων. Ωστόσο η μνήμη αυξάνεται εκθετικά ανάλογα με τις συνδέσεις που γίνονται, 
οπότε κάποια στιγμή μπορεί να χρειαστεί ανακατασκευή των ευρετηρίων. Αν και στα συγκεκριμένα datasets
(εκτός large2 με το οποίο δε πειραματιστήκαμε αρκετά ακόμα), η χρήση μνήμης είναι αρκετά χαμηλή και δε 
χρειάζεται καμία ανακατασκευή.

Η υλοποίηση με λίστες ενδείκνυται για datasets με πολλά queries και όχι τόσες πολλές εισαγωγές.
Συνεπώς, στο medium dataset η αλυσιδωτή είναι αρκετά πιο γρήγορη.

Η default υλοποίηση για το παραδοτέο αυτό είναι οι λίστες, αλλά παραδίδεται και η αλυσιδωτή. 
Για εναλλαγή, αρκεί η αντικατάσταση των CC.cpp CC.hpp με τα CC_chain.cpp CC_chain.hpp και η
επαναμεταγλώττιση του προγράμματος.

Παρατηρήθηκε ότι η ανακατασκευή δε βοηθάει καμία υλοποίηση χρονικά. Ακόμα και αν κάνουμε ανακατασκευή
σε κάθε ριπή (threshold=0), οι χρόνοι για τις επερωτήσεις δε βελτιώνονται, ακόμα και αν δε λάβουμε καν υπ όψη 
το χρονικό κόστος της κάθε ανακατασκευής. Εξαίρεση αποτελεί το medium dataset με αλυσιδωτή υλοποίηση όπου 
σημειώθηκε μικρή βελτίωση κάνοντας ανακατασκευή αποκλειστικά μια φορά.
